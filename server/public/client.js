const ws = new WebSocket('ws://localhost:8000');

function checkSameOrigin(url) {
  const locationOrigin = window.location.origin;
  const urlOrigin = new URL(url).origin;
  return locationOrigin === urlOrigin;
}

async function checkCorsHeaders(url, headers) {
  try {
    const response = await fetch(url, {
      method: 'OPTIONS',
      mode: 'cors',
      headers: {
        'Access-Control-Request-Method': 'GET',
        'Access-Control-Request-Headers': headers.join(','),
      },
    });

    if (response.ok) {
      const allowedOrigin = response.headers.get('Access-Control-Allow-Origin');
      const allowedHeaders = response.headers.get('Access-Control-Allow-Headers');
      return {
        allowedOrigin: allowedOrigin === '*' || allowedOrigin === window.location.origin,
        allowedHeaders: allowedHeaders ? allowedHeaders.split(',').map((header) => header.trim().toLowerCase()) : [],
      };
    }
  } catch (error) {
    console.error('Error sending preflight request:', error);
  }

  return { allowedOrigin: false, allowedHeaders: [] };
}

async function sendHttpRequest(data, ws) {
  const sameOrigin = checkSameOrigin(data.url);
  let allowedOrigin = false;
  let allowedHeaders = [];

  if (!sameOrigin) {
    const corsHeaders = await checkCorsHeaders(data.url, Object.keys(data.headers || {}));
    allowedOrigin = corsHeaders.allowedOrigin;
    allowedHeaders = corsHeaders.allowedHeaders;
  }

  if (sameOrigin || allowedOrigin) {
    const xhr = new XMLHttpRequest();
    xhr.onreadystatechange = () => {
      if (xhr.readyState === XMLHttpRequest.DONE) {
        const responseData = JSON.parse(xhr.responseText);
        const responseHeaders = {};
        xhr.getAllResponseHeaders().split('\r\n').forEach((header) => {
          const [key, value] = header.split(': ');
          if (key) {
            responseHeaders[key] = value;
          }
        });
        ws.send(JSON.stringify({
          data: responseData,
          headers: responseHeaders,
          status_code: xhr.status,
        }));
      }
    };
    xhr.onerror = () => {
      ws.send(JSON.stringify({ error: 'Invalid Security Context', statusCode: 0 }));
    };
    xhr.open(data.method, data.url);
    xhr.withCredentials = true;

    if (!sameOrigin) {
      Object.entries(data.headers || {}).forEach(([header, value]) => {
        if (allowedHeaders.includes(header.toLowerCase())) {
          xhr.setRequestHeader(header, value);
        }
      });
    }

    xhr.send(data.payload ? JSON.stringify(data.payload) : null);
  } else {
    ws.send(JSON.stringify({ error: 'Invalid Security Context', statusCode: 0 }));
  }
}

ws.onmessage = (event) => {
  const message = JSON.parse(event.data);
  if (message.sendRequest) {
    sendHttpRequest(message.sendRequest, ws);
  }
};